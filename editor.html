<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Rich Text Editor</title>
  <link href="https://cdn.quilljs.com/1.3.6/quill.snow.css" rel="stylesheet" />
  <script src="https://cdn.quilljs.com/1.3.6/quill.min.js"></script>
  <style>
    html, body { height: 100%; margin: 0; font-family: sans-serif; }
    /* Make only the editor area scroll */
    body { overflow: hidden; }
    #toolbar { background: #f3f3f3; border-bottom: 1px solid #ccc; padding: 6px 8px; }
    #editor { height: calc(100vh - 56px); padding: 4px 8px; overflow-y: auto; -webkit-overflow-scrolling: touch; }

    .ql-editor { padding: 4px 6px; }
    .ql-editor a {
      color: #D32F2F; font-weight: 700; text-decoration: underline; text-decoration-color: #D32F2F; line-height: 18px;
    }
    .ql-editor span { color: #000; line-height: 15px; }
    .ql-editor p { margin-top: 5px; margin-bottom: 2px; line-height: 18px; }
    .ql-editor ul { padding-left: 25px; margin-top: 2px; margin-bottom: 2px; }
    .ql-editor ol { padding-left: 30px; margin-top: 2px; margin-bottom: 2px; }
    .ql-editor li { margin-top: 0; margin-bottom: 0; list-style-position: inside; padding-left: 3px; }
    .ql-editor li p { margin-top: 0; margin-bottom: 0; }

    /* Images: keep them responsive & non-interactive so they don't steal scroll */
    .ql-editor img {
      display: block;
      max-width: 100%;
      height: auto;
      pointer-events: none; /* important for touch scroll */
      position: static !important; /* kill any inline position carry-overs */
    }

    /* Text alignment */
    .ql-editor .ql-align-center { text-align: center; }
    .ql-editor .ql-align-right  { text-align: right; }
    .ql-editor .ql-align-justify { text-align: justify; }

    /* Image alignment (no floats) */
    .ql-editor .ql-align-center img,
    .ql-editor img.ql-align-center,
    .ql-editor img[data-align="center"],
    .ql-editor [style*="text-align:center"] > img {
      margin-left: auto; margin-right: auto;
    }
    .ql-editor .ql-align-right img,
    .ql-editor img.ql-align-right,
    .ql-editor img[data-align="right"],
    .ql-editor [style*="text-align:right"] > img {
      margin-left: auto; margin-right: 0;
    }
    .ql-editor .ql-align-left img,
    .ql-editor img.ql-align-left,
    .ql-editor img[data-align="left"],
    .ql-editor [style*="text-align:left"] > img {
      margin-left: 0; margin-right: auto;
    }
  </style>
</head>
<body>
  <div id="toolbar">
    <span class="ql-formats">
      <button class="ql-bold"></button>
      <button class="ql-italic"></button>
      <button class="ql-underline"></button>
      <select class="ql-color"></select>

      <button class="ql-list" value="ordered"></button>
      <button class="ql-list" value="bullet"></button>

      <button class="ql-link"></button>
      <button class="ql-image"></button>
      <select class="ql-background"></select>

      <select class="ql-align"></select>
    </span>
  </div>

  <div id="editor"></div>

  <script>
    let quill = null;
    let isQuillReady = false;
    const pendingMessages = [];

    const safeOrigin = () => {
      return document.referrer?.startsWith('http')
        ? new URL(document.referrer).origin
        : '*';
    };

    const sendEditorReady = () => {
      if (isQuillReady) {
        window.parent.postMessage({ type: 'editorReady' }, safeOrigin());
      }
    };

    /* ---------- Helpers ---------- */
    const clamp = (n, min, max) => Math.max(min, Math.min(max, n));

    function askImageSize() {
      const useDefault = window.confirm('Use default image size 300×300px?\nOK = Default,  Cancel = Custom size');
      if (useDefault) return { width: 300, height: 300 };
      const w = parseInt(window.prompt('Enter image WIDTH in pixels (e.g., 300):', '300') || '300', 10);
      const h = parseInt(window.prompt('Enter image HEIGHT in pixels (e.g., 300):', '300') || '300', 10);
      return { width: clamp(isNaN(w) ? 300 : w, 10, 4000), height: clamp(isNaN(h) ? 300 : h, 10, 4000) };
    }

    function insertImageWithSize(dataUrl, w, h) {
      const range = quill.getSelection(true) || { index: quill.getLength(), length: 0 };
      quill.insertEmbed(range.index, 'image', dataUrl, 'user');
      quill.setSelection(range.index + 1, 0, 'silent');

      // Try to grab the <img> we just inserted
      const [leaf] = quill.getLeaf(range.index);
      let img = (leaf && leaf.domNode && leaf.domNode.tagName === 'IMG') ? leaf.domNode : null;
      if (!img) {
        const imgs = quill.root.querySelectorAll('img');
        if (imgs.length) img = imgs[imgs.length - 1];
      }

      if (img) {
        img.style.width = w + 'px';
        img.style.height = h + 'px';      // explicit px preserved in saved HTML
        img.style.maxWidth = '100%';      // responsive clamp
        img.dataset.requestedW = String(w);
        img.dataset.requestedH = String(h);
      }
      normalizeImages(); // ensure clamp vs container width
    }

    function customImageHandler() {
      const input = document.createElement('input');
      input.type = 'file';
      input.accept = 'image/*';
      input.onchange = () => {
        const file = input.files && input.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = () => {
          const { width, height } = askImageSize();
          insertImageWithSize(reader.result, width, height);
        };
        reader.readAsDataURL(file);
      };
      input.click();
    }

    // Sanitize incoming HTML & clamp images to editor width while preserving requested size
    function sanitizeAndNormalizeHTML(incomingHtml) {
      const parser = new DOMParser();
      // Wrap in a container so we can read back innerHTML safely
      const doc = parser.parseFromString('<div id="__root__"></div>', 'text/html');
      const root = doc.getElementById('__root__');
      root.innerHTML = incomingHtml || '';

      const imgs = root.querySelectorAll('img');
      imgs.forEach(img => {
        // Strip problematic positional styles/floats
        const style = img.getAttribute('style') || '';
        const cleaned = style
          .replace(/position\s*:\s*(absolute|fixed)\s*;?/ig, '')
          .replace(/z-index\s*:\s*[^;]+;?/ig, '')
          .replace(/top\s*:\s*[^;]+;?/ig, '')
          .replace(/left\s*:\s*[^;]+;?/ig, '')
          .replace(/right\s*:\s*[^;]+;?/ig, '')
          .replace(/bottom\s*:\s*[^;]+;?/ig, '')
          .replace(/float\s*:\s*[^;]+;?/ig, '');
        if (cleaned !== style) img.setAttribute('style', cleaned.trim());

        img.style.display = 'block';
        img.style.maxWidth = '100%';
        img.style.position = 'static';

        // Pull requested size if present; otherwise read px from style/attrs
        const reqW = parseInt(img.dataset.requestedW || img.getAttribute('width') || (img.style.width || '').replace('px',''), 10);
        const reqH = parseInt(img.dataset.requestedH || img.getAttribute('height') || (img.style.height || '').replace('px',''), 10);

        // Clamp width to editor width
        const editorEl = document.getElementById('editor');
        const editorWidth = Math.max(50, editorEl.clientWidth - 16); // minus padding
        if (!isNaN(reqW)) {
          const clampedW = Math.min(reqW, editorWidth);
          img.style.width = clampedW + 'px';
          if (!isNaN(reqH) && reqW > 0) {
            const ratio = reqH / reqW;
            img.style.height = Math.round(clampedW * ratio) + 'px';
          } else {
            img.style.height = 'auto';
          }
        } else {
          // No explicit size: make it fit container
          img.style.width = '100%';
          img.style.height = 'auto';
        }
      });

      return root.innerHTML;
    }

    function normalizeImages() {
      // Re-run clamp after any layout change/resize
      const html = sanitizeAndNormalizeHTML(quill.root.innerHTML);
      quill.root.innerHTML = html;
    }

    /* ---------- Initialize Quill ---------- */
    window.addEventListener('DOMContentLoaded', () => {
      quill = new Quill('#editor', {
        theme: 'snow',
        placeholder: 'Type your description...',
        modules: {
          toolbar: {
            container: '#toolbar',
            handlers: { image: customImageHandler }
          }
        }
      });

      isQuillReady = true;
      setTimeout(() => {
        sendEditorReady();
        normalizeImages();
      }, 50);

      // Drain queued messages
      while (pendingMessages.length) {
        const evt = pendingMessages.shift();
        processMessage(evt);
      }

      // Re-clamp on resize (device rotation, iframe resize)
      window.addEventListener('resize', () => {
        // debounce a bit
        clearTimeout(window.__imgClampTO);
        window.__imgClampTO = setTimeout(normalizeImages, 60);
      });
    });

    /* ---------- Messaging bridge ---------- */
    const processMessage = (event) => {
      const data = event.data;

      if (data === 'getContent') {
        const html = quill.root.innerHTML;
        window.parent.postMessage({ html }, event.origin);
        return;
      }

      if (data?.type === 'setContent') {
        const incomingHtml = data.html || '';
        // IMPORTANT: don't use clipboard.convert — it drops img sizes
        const safeHtml = sanitizeAndNormalizeHTML(incomingHtml);
        quill.root.innerHTML = safeHtml;
        // Ensure cursor is at end
        const len = quill.getLength();
        quill.setSelection(len - 1, 0, 'silent');
      }
    };

    window.addEventListener('message', (event) => {
      const data = event.data;
      if (data?.type === 'ping') {
        sendEditorReady();
        return;
      }
      if (!isQuillReady) {
        pendingMessages.push(event);
        return;
      }
      processMessage(event);
    });
  </script>
</body>
</html>

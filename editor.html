<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Rich Text Editor</title>

  <!-- Quill -->
  <link href="https://cdn.quilljs.com/1.3.6/quill.snow.css" rel="stylesheet" />
  <script src="https://cdn.quilljs.com/1.3.6/quill.min.js"></script>

  <style>
    body { margin: 0; font-family: sans-serif; }
    #toolbar { background: #f3f3f3; border-bottom: 1px solid #ccc; }

    /* Tighter container */
    #editor { height: calc(100vh - 42px); padding: 4px 8px; overflow-y: auto; }

    /* Tighter Quill defaults + centered images */
    .ql-editor { padding: 4px 6px; }
    .ql-editor p { margin-top: 0; margin-bottom: 0; }
    .ql-editor img { max-width: 100%; height: auto; display: block; margin: 0 auto; }

    /* small toolbar tweaks */
    .ql-formats .ql-zoom-out::after { content: "−"; font-weight: bold; }
    .ql-formats .ql-zoom-in::after  { content: "+"; font-weight: bold; }
    .ql-formats select.ql-img-size { min-width: 72px; }
  </style>
</head>
<body>

  <!-- Toolbar -->
  <div id="toolbar">
    <span class="ql-formats">
      <button class="ql-bold"></button>
      <button class="ql-italic"></button>
      <button class="ql-underline"></button>
      <select class="ql-color"></select>

      <button class="ql-list" value="ordered"></button>
      <button class="ql-list" value="bullet"></button>

      <button class="ql-link"></button>
      <button class="ql-image"></button>
      <select class="ql-background"></select>

      <!-- Alignment dropdown -->
      <select class="ql-align"></select>
    </span>

    <!-- 🔍 Image zoom controls -->
    <span class="ql-formats">
      <button class="ql-zoom-out" title="Zoom Out"></button>
      <button class="ql-zoom-in"  title="Zoom In"></button>
      <select class="ql-img-size" title="Image Size">
        <option selected></option>
        <option value="25">25%</option>
        <option value="50">50%</option>
        <option value="75">75%</option>
        <option value="100">100%</option>
      </select>
    </span>
  </div>

  <!-- Quill Editor -->
  <div id="editor"></div>

  <script>
    let quill = null;
    let isQuillReady = false;
    const pendingMessages = [];

    const safeOrigin = () => {
      return document.referrer?.startsWith('http')
        ? new URL(document.referrer).origin
        : '*';
    };

    const sendEditorReady = () => {
      if (isQuillReady) {
        window.parent.postMessage({ type: 'editorReady' }, safeOrigin());
      }
    };

    // --- Image helpers ---
    function getSelectedImage() {
      const range = quill.getSelection();
      if (!range) return null;
      let [leaf] = quill.getLeaf(range.index);
      if (leaf && leaf.domNode && leaf.domNode.tagName === 'IMG') {
        return leaf.domNode;
      }
      // If cursor is just after the image, look back one position
      if (range.index > 0) {
        [leaf] = quill.getLeaf(range.index - 1);
        if (leaf && leaf.domNode && leaf.domNode.tagName === 'IMG') {
          return leaf.domNode;
        }
      }
      return null;
    }

    function setImageWidthPercent(percent) {
      const img = getSelectedImage();
      if (!img) { console.warn('No image selected to resize'); return; }
      const pct = Math.max(10, Math.min(200, Number(percent) || 100));
      img.style.width = pct + '%';
      img.style.maxWidth = '100%';
      img.style.height = 'auto';
      // keep block/center; user can re-align using toolbar if desired
    }

    function adjustImageWidth(deltaPercent) {
      const img = getSelectedImage();
      if (!img) { console.warn('No image selected to resize'); return; }

      const editorW = quill.root.clientWidth || (img.parentElement && img.parentElement.clientWidth) || 1;

      // derive current % from style or measured width
      let currentPct = 100;
      const sw = (img.style.width || '').trim();
      if (sw.endsWith('%')) {
        currentPct = parseFloat(sw);
      } else if (sw.endsWith('px')) {
        const px = parseFloat(sw);
        currentPct = Math.round((px / editorW) * 100);
      } else {
        currentPct = Math.round((img.offsetWidth / editorW) * 100);
      }

      const next = Math.max(10, Math.min(200, currentPct + deltaPercent));
      img.style.width = next + '%';
      img.style.maxWidth = '100%';
      img.style.height = 'auto';
    }

    // --- Initialize Quill with custom handlers ---
    window.addEventListener('DOMContentLoaded', () => {
      quill = new Quill('#editor', {
        theme: 'snow',
        placeholder: 'Type your description...',
        modules: {
          toolbar: {
            container: '#toolbar',
            handlers: {
              'zoom-in': () => adjustImageWidth(+10),
              'zoom-out': () => adjustImageWidth(-10),
              'img-size': function (value) {
                if (value) {
                  setImageWidthPercent(value);
                  // reset dropdown to placeholder so user can pick same value again
                  const sel = this.container.querySelector('select.ql-img-size');
                  if (sel) sel.selectedIndex = 0;
                }
              }
            }
          }
        }
      });

      isQuillReady = true;
      setTimeout(sendEditorReady, 50);

      // Drain any queued messages
      while (pendingMessages.length) {
        const evt = pendingMessages.shift();
        processMessage(evt);
      }
    });

    // Process messages that require Quill
    const processMessage = (event) => {
      const data = event.data;

      if (data === 'getContent') {
        const html = quill.root.innerHTML;
        window.parent.postMessage({ html }, event.origin);
        return;
      }

      if (data?.type === 'setContent') {
        const incomingHtml = data.html || '';
        try {
          const delta = quill.clipboard.convert(incomingHtml);
          quill.setContents(delta);
        } catch (e) {
          console.error('❌ Failed to set Quill content via delta; falling back to innerHTML.', e);
          quill.root.innerHTML = incomingHtml;
        }
      }
    };

    // Global message handler (queue until ready)
    window.addEventListener('message', (event) => {
      const data = event.data;

      if (data?.type === 'ping') {
        sendEditorReady();
        return;
      }

      if (!isQuillReady) {
        pendingMessages.push(event);
        return;
      }

      processMessage(event);
    });
  </script>
</body>
</html>
